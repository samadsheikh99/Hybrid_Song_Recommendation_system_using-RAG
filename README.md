Hybrid Song Recommendation System Using Retrieval-Augmented Generation (RAG)
Overview
This project implements a Hybrid Song Recommendation System that combines content-based filtering and collaborative filtering using Retrieval-Augmented Generation (RAG). The system leverages the Million Song Dataset from Spotify and LastFM to recommend songs based on their metadata (title, artist, tags) and user listening history (play counts). The RAG framework enhances recommendations by integrating a large language model (LLM) to provide conversational, context-aware responses.
The system uses LangChain for document processing and retrieval, Hugging Face for embeddings and LLMs, and FAISS for efficient vector storage and similarity search. The hybrid approach combines content similarity (via embeddings) with collaborative signals (via normalized play counts) to rank and recommend songs.
Features

Content-Based Filtering: Uses song metadata (title, artist, tags) to find similar songs based on semantic embeddings.
Collaborative Filtering: Incorporates user listening history (play counts) to weigh popular songs.
RAG Pipeline: Combines a retriever (FAISS with MMR search) and a generative LLM (MistralAI Mixtral-8x7B) for conversational recommendations.
Customizable Recommendations: Allows users to specify the number of recommendations (default: 5).
Debugging Support: Includes detailed logging of retrieved documents and indices for transparency and troubleshooting.

Dataset
The system uses the Million Song Dataset from Kaggle, which includes:

Music Info: Song metadata (track ID, title, artist, tags, etc.).
User Listening History: Play counts for songs by users.

The dataset is merged on track_id to create a unified dataframe with song metadata and play counts. A subset of 100,000 rows is used for faster processing.
Requirements
To run this project, install the following Python libraries:
pip install langchain langchain-community sentence-transformers faiss-cpu pandas numpy
pip install transformers huggingface_hub langchain_huggingface

Additionally eugenics Note: A Hugging Face API token is required for the LLM. Set it in the environment variable:
os.environ["HUGGINGFACEHUB_API_TOKEN"] = "your-huggingface-token"

Project Structure
The main script (Hybrid_Song_Recommendation_System.py) includes the following steps:

Data Loading and Preprocessing:
Loads and merges the Music Info and User Listening History datasets.
Combines title, artist, and tags into a single metadata field.
Handles missing play counts and samples a subset for processing.


Document Creation:
Converts the dataset into LangChain Document objects with metadata (index, track ID, title, artist).


Embedding and Vector Store:
Uses sentence-transformers/all-MiniLM-L6-v2 for embeddings.
Stores embeddings in a FAISS vector store for efficient similarity search.


Retriever Setup:
Configures a retriever with Maximum Marginal Relevance (MMR) search to retrieve the top 10 similar songs.


Prompt Template:
Defines a conversational prompt for the LLM to generate recommendations based on retrieved songs.


LLM Integration:
Uses mistralai/Mixtral-8x7B-Instruct-v0.1 via Hugging Face's endpoint for text generation.


Hybrid Recommendation:
Combines content similarity scores (from embeddings) and normalized play counts to rank recommendations.
Returns the top-N recommendations with explanations generated by the LLM.



How It Works

Input: The user provides a song name (e.g., "Sentimental Heart").
Retrieval: The retriever fetches the top 10 similar songs based on metadata embeddings using MMR.
Ranking: A hybrid score is calculated (70% content similarity + 30% normalized play count).
Generation: The LLM generates a conversational response listing the top-N recommendations with reasons (e.g., similar genre, artist, or tags).
Output: The system prints the recommendations in a user-friendly format.

Example Usage
song_input = "Sentimental Heart"
response = recommend_songs(song_input, num_recommendations=5)
print(f"Recommendations for '{song_input}':")
print(response)

Sample Output:
Recommendations for 'Sentimental Heart':
Here are 5 song recommendations similar to "Sentimental Heart" by She & Him:

1. **"Why Do You Let Me Stay Here?" by She & Him (tags: indie, folk-pop)**  
   This song shares the same indie folk-pop vibe and is by the same artist, making it a great match.

2. **"Lua" by Bright Eyes (tags: indie, folk)**  
   Similar introspective and emotional indie folk style, with a focus on heartfelt lyrics.

3. **"The Way I Am" by Ingrid Michaelson (tags: indie, pop)**  
   This song's light, melodic indie pop sound complements the style of "Sentimental Heart."

4. **"First Day of My Life" by Bright Eyes (tags: folk, indie)**  
   Another folk-inspired track with a similar emotional and acoustic feel.

5. **"Mushaboom" by Feist (tags: indie, folk-pop)**  
   Feist's soft, melodic style and indie folk-pop tags align closely with the input song.

Setup Instructions

Download the Dataset:

Obtain a Kaggle API token (kaggle.json) and place it in the ~/.kaggle/ directory.
Run the script to download and unzip the dataset:mkdir -p ~/.kaggle
cp kaggle.json ~/.kaggle/
chmod 600 ~/.kaggle/kaggle.json
kaggle datasets download -d undefinenull/million-song-dataset-spotify-lastfm
unzip million-song-dataset-spotify-lastfm.zip




Set Up Hugging Face API:

Replace "PLACE YOUR HUGGINGFACE TOKEN" with your Hugging Face API token in the script.


Run the Script:

Execute the Python script to start the recommendation system.



Limitations

Dataset Size: The system uses a subset of 100,000 rows for faster processing. For larger datasets, adjust the df_subset sampling or use the full dataset (may require more memory and time).
API Dependency: Requires a Hugging Face API token for the LLM. Ensure a valid token is set.
Processing Time: Embedding generation and retrieval may take time for large datasets or complex queries.
MMR Search: The MMR algorithm balances relevance and diversity, but tuning lambda_mult may be needed for optimal results.

Future Improvements

Scalability: Optimize for larger datasets using distributed computing or batch processing.
Personalization: Incorporate user-specific listening history for personalized recommendations.
Advanced Ranking: Experiment with different weights for content and collaborative signals.
UI Integration: Develop a web or app interface for easier user interaction.

Contributing
Contributions are welcome! Please submit pull requests or issues to the GitHub repository.
